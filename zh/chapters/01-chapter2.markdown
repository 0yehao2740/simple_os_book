# 操作系统简介 #

 * [要点（OSP）：OS定义] 
 * [要点（OSP）：OS抽象]

## 应具备的背景知识和学习环境 ##

设计实现操作系统其实就是设计实现一个软件，所以本书的例子和描述需要读者学习过计算机原理课程、程序设计课程，掌握C语言编程（了解指针等的编程），对基于Intel 80386处理器体系结构有一定的了解，大致了解基于基于Intel 80386的汇编语言。本书涉及的例子和实验可在Windows环境和Linux环境下采用命令行（CLI）方式和集成开发环境（IDE）方式进行编译和运行，所以，最好能够有一台PC计算机用于进行操作系统实验。

## 操作系统的概念  ##

### 操作系统的定义 ###
操作系统是计算机系统机构中的一个系统软件，它的职能主要有两个：对下面（也就是计算机硬件），有效地组织和管理计算机系统中的硬件资源（包括处理器、内存、硬盘、显示器、键盘、鼠标等各种外设）；对上面（应用程序或用户），提供简洁的服务功能接口，屏蔽硬件管理带来的差异性和复杂性，使得应用程序和用户能够灵活、方便、有效地使用计算机。为了完成这两个职能，操作系统需要在其内部实现中合理地组织计算机中的软硬件资源的使用分配和处理流程，使整个计算机系统能高效地运行。


### 操作系统的抽象 ###
操作系统为了能够更好地管理计算机系统并对应用程序提供便捷的服务，在操作系统的发展过程中，计算机科学家提出了如下四个个抽象概念，奠定了操作系统的基础。操作系统原理中的其他概念基本上都可基于上述这四个操作系统抽象。

#### 中断（Interrupt）####

简单地说，中断是处理器在执行过程中的突变，用来响应处理器状态中的特殊变化。比如当应用程序正在执行时，产生了时钟外设中断，导致操作系统打断当前应用程序的执行，转而去处理时钟外设中断，处理完毕后，再回到应用程序被打断的地方继续执行。在操作系统中，有三类中断：外设中断（Device Interrupt）、陷阱中断（Trap Interrupt）和故障中断（Fault Interrupt，也称为exception，异常）。外设中断由外部设备引起的外部I/O事件如时钟中断、控制台中断等。外设中断是异步产生的，与处理器的执行无关。故障中断是在处理器执行指令期间检测到不正常的或非法的内部事件（如除零错、地址访问越界）。陷阱中断是在程序中使用请求操作系统服务的系统调用而引发的有意事件。在后面的叙述中，如果没有特别指出，我们将用简称中断、陷阱、故障来区分这三种特殊的中断事件，在不需要区分的地方，统一用中断表示。

#### 进程（Process） ####

简单地说，进程是一个正在运行的程序。在计算机系统中，我们可以“同时”运行多个程序，这个“同时”，其实是操作系统给用户造成的一个“幻觉”。大家知道，处理器是计算机系统中的硬件资源。为了提高处理器的利用率，操作系统采用了多道程序技术。如果一个程序因某个事件而不能运行下去时，就把处理器占用权转交给另一个可运行程序。为了刻画多道程序的并发执行的过程，就要引入进程的概念。从操作系统原理上看，一个进程是一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。操作系统中的进程管理需要协调多道程序之间的关系，解决对处理器分配调度策略、分配实施和回收等问题，从而使得处理器资源得到最充分的利用。

#### 虚存（Virtual Memory） ####

简单地说，虚存就是操作系统通过处理器中的MMU硬件的支持而给应用程序和用户提供一个大的（超过计算机中的内存条容量）、一致的（连续的地址空间）、私有的（其他应用程序无法破坏）的存储空间。这需要操作系统将内存和硬盘结合起来管理，为用户提供一个容量比实际内存大得多的虚拟存储器，并且需要操作系统为应用程序分配内存空间，使用户存放在内存中的程序和数据彼此隔离、互不侵扰。操作系统中的虚存管理与处理器的MMU密切相关。

####  文件（File） ####

简单地说，文件就是存放在永久存储介质（比如硬盘、光盘、U盘等）上，方便应用程序和用户读写的数据。当处理器需要访问文件中的数据时，可通过操作系统把它们装入内存。放在硬盘上的程序也是一种文件。文件管理的任务是有效地支持文件的存储、检索和修改等操作。

## “麻雀”操作系统--ucore ##
写一个操作系统难吗？别被现在上百万行的Linux和Windows操作系统吓倒。当年Thompson乘他老婆带着小孩度假留他一人在家时，写了UNIX；当年Linus还是一个21岁大学生时完成了Linux雏形。站在这些巨人的肩膀上，我们能否也尝试一下做“巨人”的滋味呢？

MIT的Frans Kaashoek等在2006年参考PDP-11上的UNIX Version 6写了一个可在X86上跑的操作系统xv6（基于MIT License），用于学生学习操作系统。我们可以站在他们的肩膀上，基于xv6的设计，尝试着一步一步完成一个从“空空如也”到“五脏俱全”的“麻雀”操作系统—ucore，此“麻雀”包含虚存管理、进程管理、处理器调度、同步互斥、进程间通信、文件系统等主要内核功能，总的内核代码量（C+asm）不会超过5K行。充分体现了“小而全”的指导思想。

ucore的运行环境可以是真实的X86计算机，不过考虑到调试和开发的方便，我们可采用X86模拟器，比如QEMU、BOCHS等，或X86虚拟运行环境，比如VirtualBox、VMware Player等。ucore的开发环境主要是GCC中的gcc、gas、ld和MAKE等工具，也可采用集成了这些工具的IDE开发环境Eclipse-CDT。运行环境和开发环境既可以在Linux或Windows中使用。

那我们准备如何一步一步实现ucore呢？安装一个操作系统的开发过程，我们可以有如下的开发步骤：

 1. 启动操作系统：了解操作系统启动前bootloader的状态和要做的准备工作；了解运行硬件保护模式；操作系统如何加载到内存中；理解两类中断--“外设中断”，“陷阱中断”，内核态和用户态的区别；
 2. 物理内存：理解x86分段/分页模式；了解操作系统如何管理物理内存；了解连续内存分配算法；
 3. 虚拟内存：理解内存访问错误异常的处理、以及虚存如何利用此异常处理来实现内存替换和页替换算法；
 3. 内核线程：了解内核线程的创建过程，以及内核线程如何实现上下文切换的；
 4. 用户进程：了解进程管理；了解进程创建、执行、切换和结束的动态管理过程；了解在用户态通过系统调用得到内核态的内核服务的过程；
 4. 处理器调度：理解操作系统的处理器调度过程和调度算法；
 5. 同步互斥：了解同步互斥的具体实现以及对系统性能的影响，了解死锁产生的原因，以及如何避免死锁；了解进程间通信机，以及进程间如何进行多种方式的信息交换和共享；
 7. 文件系统：了解文件系统的具体实现；文件系统与进程管理等的关系；了解缓存对操作系统IO访问的性能改进，了解虚拟文件系统（VFS）、buffer cache和disk driver之间的关系。

其中每个开发步骤都是建立在上一个步骤之上的，就像搭积木，从一个一个小木块，最终搭出来一个小房子。在搭房子的过程中，完成从理解操作系统原理到实践操作系统设计与实现的探索过程。这个房子最终的建筑架构和建设进度如下图所示：

![ucore操作系统总体结构](figures/chapt1-ucore-arch.png)

## ucore实验过程 ##

### lab1 ：启动操作系统

#### 启动/保护模式

   * proj1     : bootloader 能切换到x86-32保护模式且能显示字符串
   * proj2   (<--proj1)     : bootloader能读磁盘且加载ELF格式的文件
   * proj3   (<--proj2)     : bootloader能ELF执行文件格式的toy OS

#### 显示函数调用栈

   * proj3.1  (<--proj3)     : ucore能输出函数调用栈信息

#### 响应外设中断

   * proj4  (<--proj3.1)   : ucore可处理外设中断

#### 支持系统调用机制

   * proj4.1  (<--proj4)     : 准备支持系统调用机制
   * proj4.1.1(<--proj4.1) : 用中断机制实现系统调用机制
   * proj4.1.2(<--proj4.1) : 用门gate机制实现系统调用机制
   
#### 支持远程gdb调试

   * proj4.2     (<--proj4.1)   : ucore增加 gdb remote server/stub，这样可以通过gdb远程调试ucore
   * proj4.3     (<--proj4.2)   : ucore支持硬件breakpoint和watchpoint，从而具有内部debugger功能

### lab2 ：物理内存管理

#### 物理内存管理

 * proj5    (<--proj4.3)   : ucore支持保护模式下的分页机制，并能够管理物理内存

#### 连续物理内存分配算法                         

 * proj5.1     (<--proj5)     : 最佳适配算法
 * proj5.1.1   (<--proj5.1)   : 首次适配算法
 * proj5.1.2   (<--proj5.1)   : 最坏适配算法

#### buddy连续物理内存分配算法

 * proj5.2     (<--proj5.1)   : 伙伴（buddy）分配算法

#### slab连续物理内存分配算法

 * proj6       (<--proj5.2)   : SLAB内存分配算法

### lab3 ：虚拟内存管理


#### 支持页访问错误异常的处理

 * proj7       (<--proj6)     : 能够有页访问错误异常的处理机制，提供了虚存管理（VMM）的框架

#### 提供swap机制

 * proj8       (<--proj7)     : 实现swap in/out机制，并加入页替换算法的实现框架

#### 实现map/unmap等机制

 * proj9       (<--proj8)     : 增加内核函数map, unmap, dup, exit等

#### 实现share memory机制

 * proj9.1     (<--proj9)     : 实现 shmem_t内存结构，并完成香港函数，实现share memory

#### 实现COW机制

 * proj9.2     (<--proj9.1)   : 实现支持高效进程复制的虚存核心功能Copy On Write（简称COW）

### lab4 ：内核线程管理

#### 创建内核线程

 * proj10      (<--proj9.2)   : 实现线程和进程管理的关键数据结构进程控制块（Process Control Block, 简称PCB），完成对内核线程的创建所需功能，并建立基本的调度机制，主要是体现能够切换两个内核线程。

### lab5 ：用户进程管理

#### 实现进程管理框架

 * proj10.1    (<--proj10)    : 实现用户进程管理框架，并完成与创建用户进程相关的内核函数（读ELF格式的文件、fork、execve），以及与调度进程相关的调度器

#### 与进程生命周期相关

 * proj10.2    (<--proj10.1)  : 实现进程管理相关的系统调用 wait、kill、exit

#### 内存堆管理系统调用

 * proj10.3    (<--proj10.2)  : 完成管理用户进程的内存堆（heap）的系统调用sys_brk

#### 睡眠和唤醒系统调用

 * proj10.4    (<--proj10.3)  : 完成用户进程调度相关的函数sleep，并增加timer的功能支持

#### 采用内核线程机制支持swap虚存功能

 * proj11      (<--proj10.4)  : 用内核线程方式实现虚存的swap机制

#### 实现用户态的线程

 * proj12      (<--proj11)    : 实现系统调用map、unmap和共享内存share memory，实现用户态线程机制;

### lab6 ：处理器调度

#### OS教材上的调度算法

 * proj13      (<--proj12)    : 实现通用调度框架和简单的想来先服务（First Come First Serve，简称FCFS）调度算法
 * proj13.1    (<--proj13)    : 实现轮转（RoundRobin，简称RR）掉短算法
 * proj13.2    (<--proj13.1)  : 实现多级反馈队列（MultiLevel Feedback Queue，简称MLFQ）调度算法
 
### lab7  : 同步互斥和进程间通信

#### OS教材上的信号量机制

 * proj14      (<--proj13.2)  : 实现内核中的信号量（semaphore）机制

#### 用户态进程的信号量

 * proj14.1    (<--proj14)    : 实现用于用户态进程/线程的信号量机制,
 * proj14.2    (<--proj14.1)  : 增加在信号量等待中的超时判断机制

#### 其他一些IPC机制

 * proj15      (<--proj14.2)  : 实现事件（event ）IPC机制
 * proj16      (<--proj15)    : 实现邮箱（mailbox）IPC机制

####  管程（Monitor）和条件变量机制

 * proj16.1      (<--proj16)    : 实现管程和条件变量
 
###  lab8  : 文件系统

#### 建立虚拟文件系统

 * proj17      (<--proj16)    : 实现vfs框架, file数据结构和相关操作，文件化各种输入输出外设(stdin, stdout, null)

#### 按照文件的方式实现管道（PIPE）

 * proj17.1    (<--proj17)    : 实现匿名管道（PIPE）和有名管道（FIFO）

####  增加SFS 

 * proj18      (<--proj17.1)  : 在VFS上增加具体文件系统实例sfs 'simple filesystem'和对应的文件操作相关函数

#### 增加sfs中目录访问相关的函数

 * proj18.1    (<--proj18)    : 增加mkdir/link/rename/unlink (hard link)相关的系统调用和内核函数

#### 加载存储在磁盘上的执行文件并运行

 * proj18.2    (<--proj18)    : add exec

#### 能够带上执行参数的exec功能 

 * proj18.3    (<--proj18.2)  : add exec with arguments (at most 32)

#### 实现用户态的命令行交互执行程序shell

 * proj19      (<--proj18.3)  : shell


 
